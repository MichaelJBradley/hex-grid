using System;
using System.Collections.Generic;
using UnityEngine;

namespace Grid
{
    public class RectangularGridGenerator : MonoBehaviour, IGridGenerator
    {
        public uint length;
        public uint width;
        public HexTypes hexType;
        public bool useMeshes = true;
        public bool useColliders = true;

        public Material hexTileMaterial;

        // Use a list of tile properties to define the tiles.
        public List<TilePropertyScriptableObject> tiles;

        /// <summary>
        /// Generate a rectangular grid supporting either
        /// <c>HexTypes.PointyTop</c> or <c>HexTypes.FlatTop</c>.
        /// </summary>
        /// <param name="hexes"></param>
        /// <exception cref="NullReferenceException"></exception>
        public void Generate(Dictionary<Hex, HexTile> hexes)
        {
            if (hexes == null)
            {
                throw new NullReferenceException();
            }

            // Determine offset coordinate ranges from length and width
            // This set of ranges puts the Hex origin as close to the middle as possible.
            int left = (int)Mathf.Ceil(width / -2.0f + .5f);
            int right = (int)Mathf.Floor(width / 2.0f);
            int top = (int)Mathf.Ceil(length / -2.0f + .5f);
            int bot = (int)Mathf.Floor(length / 2.0f);
            // The grid is generated by first iterating from top to bottom for pointy topped or left to right for flat
            // topped HexTiles.
            Vector2 min = new Vector2();
            Vector2 max = new Vector2();
            switch (hexType) {
                case HexTypes.PointyTop:
                    min = new Vector2(top, left);
                    max = new Vector2(bot, right);
                    break;
                case HexTypes.FlatTop:
                    min = new Vector2(left, top);
                    max = new Vector2(right, bot);
                    break;
            }

            for (int x = (int)min.x; x <= (int)max.x; x++)
            {
                // Convert offset coordinates to axial to generate HexTiles.
                // The axis being iterated over first determines whether the offset affects Q or R.
                int q = 0;
                int r = 0;
                int offset = 0;
                switch (hexType) {
                    case HexTypes.PointyTop:
                        // Note: Changing x in the Floor call to (x + 1) or (x - 1), will shift even rows instead of odd
                        offset = (int)Mathf.Floor(x / 2.0f);
                        r = x;
                        break;
                    case HexTypes.FlatTop:
                        offset = (int)Mathf.Floor(x / 2.0f);
                        q = x;
                        break;
                }
                // Iterate over the second axis shifting tiles by .5 for each odd row. 
                // The total number of hexes generated in the second iteration is always the same, the only difference
                // being where the hex coord starts.
                for (int y = (int)min.y - offset; y <= (int)max.y - offset; y++)
                {
                    // Determine the other Hex coord based on pointy/flat topped
                    switch (hexType) {
                        case HexTypes.PointyTop:
                            q = y;
                            break;
                        case HexTypes.FlatTop:
                            r = y;
                            break;
                    }

                    // Create the position of the HexTile.
                    Hex pos = new Hex(q, r);
                    // Create the GameObject and set the parent
                    GameObject hex = new GameObject(pos.ToString());
                    hex.transform.parent = transform;

                    // Get a tile property scriptable object at random to determine this HexTile's properties
                    TilePropertyScriptableObject tileProps = tiles[UnityEngine.Random.Range(0, tiles.Count)];

                    // Create meshes and colliders based on the script's settings.
                    if (useMeshes)
                    {
                        hex.AddComponent<MeshFilter>();
                        MeshRenderer renderer = hex.AddComponent<MeshRenderer>();
                        renderer.sharedMaterial = hexTileMaterial;
                        renderer.material.color = tileProps.color;
                    }
                    if (useColliders)
                    {
                        hex.AddComponent<MeshCollider>();
                    }

                    // Create the HexTile and set vertices only if meshes or colliders are used.
                    // No sense creating the vertices if neither of the components that use them exist.
                    HexTile hexTile = hex.AddComponent<HexTile>();
                    hexTile.pos = pos;
                    if (useMeshes || useColliders)
                    {
                        // Because the vertices are being calculated, either flat or pointy topped Hex types can be
                        // used.
                        hexTile.vertices = HexVertices.GetVertices(pos, hexType);
                        // GetVertices always puts the center vertex at element 0.
                        hexTile.center = hexTile.vertices[0];
                        hexTile.triangles = HexVertices.Triangles;
                    }
                    
                    // Add IHexTileProperty scripts to reference the TilePropertyScriptableObject's properties.
                    HexTilePropertiesInt32 propsI = hex.AddComponent<HexTilePropertiesInt32>();
                    propsI.properties = tileProps.propsInt;
                    HexTilePropertiesBoolean propsB = hex.AddComponent<HexTilePropertiesBoolean>();
                    propsB.properties = tileProps.propsBool;

                    hexes[pos] = hexTile;
                }
            }
        }
    }
}
